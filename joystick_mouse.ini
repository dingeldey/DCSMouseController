[input]
; --- Primary device (GUID first, index second) ---
device_guid =
device_index = 0

; --- Optional separate modifier device (else primary is used) ---
modifier_device_guid =
modifier_device_index =
modifier_button = 6        ; 1-based! button that acts as "modifier" (must be HELD)

; --- Toggle and nudge with buttons (1-based indices; append 'M' to require modifier) ---
button_toggle = 5          ; press to toggle ON; press again to toggle OFF (1-based)
button_off =               ; optional dedicated OFF button, e.g. 24 or 24M (1-based)

button_inc_x = 12M         ; hold to nudge right
button_dec_x = 11M         ; hold to nudge left
button_inc_y = 9M          ; hold to nudge down
button_dec_y = 10M         ; hold to nudge up

nudge_velocity_px_s = 4000  ; pixels/second while the respective nudge button is held
wiggle_one_pixel = true     ; Used to keep cursor alive in DCS. DCS will eventually not accept mouse changes to same position

; --- Axis-based movement (0-based axis indices; append 'M' to require modifier) ---
; Leave empty to disable. Axis values in [-1..1] are scaled by axis_velocity_px_s.
axis_x = 0M                ; e.g. 0 or 0M  (right is +)
axis_y = 1M                ; e.g. 1 or 1M  (down is +)

; Per-axis deadzones and invert:
axis_deadzone_x = 0.01     ; 0..1 : values with |v| < deadzone are ignored (X)
axis_deadzone_y = 0.01     ; 0..1 : values with |v| < deadzone are ignored (Y)
axis_invert_x = false      ; set true to flip axis polarity (X)
axis_invert_y = false      ; set true to flip axis polarity (Y)

axis_velocity_px_s = 800   ; pixels/second at |axis| = 1.0

; --- Map joystick buttons to mouse clicks (1-based; optional 'M') ---
button_mouse_left  = 2
button_mouse_right = 4

; --- Mouse wheel (two buttons; hold to scroll) ---
button_wheel_up   = 8
button_wheel_down = 7
wheel_ticks_per_second = 30  ; scroll ticks per second while held (per button)

; --- Axis-as-button mappings (thresholded; optional 'M' to require modifier) ---
; Format: axis:<index>:<pos|neg|abs>:<threshold>[M]
; Example: axisbtn_mouse_left = axis:2:pos:0.65M   ; press left-click when axis 2 >= +0.65 with modifier
;          axisbtn_wheel_down = axis:3:neg:0.50    ; hold wheel down when axis 3 <= -0.50
axisbtn_mouse_left  = axis:2:neg:0.50
axisbtn_mouse_right = axis:2:pos:0.50
axisbtn_wheel_up    = axis:3:pos:0.50      ;axis:2:neg:0.50
axisbtn_wheel_down  = axis:3:neg:0.50     ;axis:2:pos:0.50
axis_button_hysteresis = 0.10

; --- Monitor selection & target (within THAT monitor) ---
monitor_index = 0          ; see printed monitor list at startup
x_frac = 0.5               ; preferred (0..1 within the selected monitor)
y_frac = 0.5
x = 1280                   ; pixels within selected monitor (ignored if frac set)
y = 720

; --- Repeater & loop ---
repeat_ms = 1000
poll_hz = 250
startup_grace_ms = 200

; --- Windows input path (recommended for sims) ---
use_sendinput = true

; Limit the target to the selected monitor or to the whole virtual desktop
; values: monitor | virtual
clamp_space = virtual

; --- Behavior / debug ---
toggle_feedback = true
log_apply = false
debug_buttons = false
debug_io = false           ; print monitored inputs and generated outputs

; Optional (defaults to false if omitted):
; restore_on_off = false    ; if true, restore the pre-toggle cursor when turning OFF
